#' DiscountFactor class
#'
#' The `DiscountFactor` class is designed to represent discount factors. Checks
#' whether: `d1` is less than `d2`, elementwise, and that both are `Date`
#' vectors; and `value` is greater than zero and is a numeric vector. An error
#' is thrown if any of these are not true. The elements of each argument are
#' recycled such that each resulting vectors have equivalent lengths.
#'
#' @param value a numeric vector containing discount factor values. Must be
#'   greater than zero
#' @param d1 a `Date` vector containing the as of date
#' @param d2 a `Date` vector containing the date to which the discount factor
#'   applies
#' @return a (vectorised) `DiscountFactor` object
#' @examples
#' library("lubridate")
#' df <- DiscountFactor(c(0.95, 0.94, 0.93), ymd(20130101),
#'   ymd(20140101, 20150101, 20140101))
#' as_InterestRate(df, 2, "act/365")
#' @export

DiscountFactor <- function(value, d1, d2) {
  c(value, d1, d2) %<-% vec_recycle_common(value, d1, d2)
  validate_DiscountFactor(new_DiscountFactor(value, d1, d2))
}

new_DiscountFactor <- function(value = double(), d1=new_date(), d2=new_date()) {
  vec_assert(value, ptype = double())
  vec_assert(d1, ptype = new_date())
  vec_assert(d2, ptype = new_date())

  new_rcrd(list(
    value = value,
    start_date = d1,
    end_date = d2
  ), class = "DiscountFactor")
}

validate_DiscountFactor <- function(x) {
  assertthat::assert_that(
    all(field(x, "value") > 0),
    all(field(x, "start_date") <= field(x, "end_date"))
  )
  x
}

#' InterestRate class
#'
#' The `InterestRate` class is designed to represent interest rates. Checks
#' whether: the `day_basis` is valid; and the `compounding` is valid. An error
#' is thrown if any of these are not true. The elements of each argument are
#' recycled such that each resulting vectors have equivalent lengths.
#'
#' @param value a numeric vector containing interest rate values (as decimals).
#' @param compounding a numeric vector representing the [compounding] frequency.
#' @param day_basis a character vector representing the day basis associated
#'   with the interest rate (see [fmdates::year_frac()])
#' @return a vectorised `InterestRate` object
#' @examples
#' library("lubridate")
#' InterestRate(c(0.04, 0.05), c(2, 4), 'act/365')
#' rate <- InterestRate(0.04, 2, 'act/365')
#' as_DiscountFactor(rate, ymd(20140101), ymd(20150101))
#' as_InterestRate(rate, compounding = 4, day_basis = 'act/365')
#' @export

InterestRate <- function(value, compounding, day_basis) {
  validate_InterestRate(new_InterestRate(value, compounding, day_basis))
}

new_InterestRate <- function(value, compounding, day_basis) {
  vec_assert(value, ptype = double())
  vec_assert(day_basis, ptype = character())
  c(value, compounding, day_basis) %<-%
    vec_recycle_common(value, compounding, day_basis)

  new_rcrd(
    list(value = value, day_basis = day_basis, compounding = compounding),
    class = "InterestRate"
  )
}

validate_InterestRate <- function(x) {
  assertthat::assert_that(
    fmdates::is_valid_day_basis(field(x, "day_basis")),
    is_valid_compounding(field(x, "compounding"))
  )
  x
}


#' Coerce to InterestRate
#'
#' You can coerce objects to the `InterestRate` class using this method.
#'
#' @param x object to coerce
#' @param ... other parameters passed to methods
#' @return an `InterestRate` object
#' @examples
#' library("lubridate")
#' as_InterestRate(DiscountFactor(0.95, ymd(20130101), ymd(20140101)),
#'   compounding = 2, day_basis = "act/365")
#' as_InterestRate(InterestRate(c(0.04, 0.05), c(2, 4), 'act/365'),
#'   compounding = 4, day_basis = 'act/365')
#' @export
as_InterestRate <- function(x, ...) UseMethod("as_InterestRate")

#' @inheritParams InterestRate
#' @rdname as_InterestRate
#' @export
as_InterestRate.DiscountFactor <- function(x, compounding, day_basis, ...) {
  assertthat::assert_that(
    fmdates::is_valid_day_basis(day_basis),
    is_valid_compounding(compounding)
  )
  term <- fmdates::year_frac(
    field(x, "start_date"),
    field(x, "end_date"),
    day_basis
  )
  is_cc <- is.infinite(compounding)
  is_simple <- compounding == 0
  is_tbill <- compounding == -1
  is_pc <- !(is_cc | is_simple | is_tbill)

  df_value <- field(x, "value")
  rate <- vector("numeric", length(x))
  rate[is_cc] <- -log(df_value) / term
  rate[is_simple] <- (1 / df_value - 1) / term
  rate[is_tbill] <- (1 - df_value) / term
  rate[is_pc] <- compounding *
    ((1 / df_value) ^ (1 / (compounding * term)) - 1)
  new_InterestRate(rate, compounding, day_basis)
}

#' @inheritParams InterestRate
#' @rdname as_InterestRate
#' @export
as_InterestRate.InterestRate <-
  function(x,
           compounding = NULL,
           day_basis = NULL,
           ...) {
    if (!all(is.null(compounding), is.null(day_basis))) {
    # start and end dates here don't matter.
    df <- as_DiscountFactor(x, as.Date("2013-01-01"), as.Date("2014-01-01"))
    if (is.null(compounding)) {
      compounding <- field(x, "compounding")
    }
    if (is.null(day_basis)) {
      day_basis <- field(x, "day_basis")
    }
    return(as_InterestRate(df, compounding, day_basis))
  } else {
    return(x)
  }
}

#' Coerce to DiscountFactor
#'
#' You can coerce objects to the `DiscountFactor` class using this method.
#'
#' @param x object to coerce
#' @param ... other parameters passed to methods
#' @return a `DiscountFactor` object
#' @examples
#' library("lubridate")
#' as_DiscountFactor(InterestRate(c(0.04, 0.05), c(2, 4), 'act/365'),
#'   ymd(20140101), ymd(20150101))
#' @export
as_DiscountFactor <- function(x, ...) UseMethod("as_DiscountFactor")
#' @inheritParams DiscountFactor
#' @rdname as_DiscountFactor
#' @export
as_DiscountFactor.InterestRate <- function(x, d1, d2, ...) {
  assertthat::assert_that(
    lubridate::is.Date(d1),
    lubridate::is.Date(d2)
  )
  # year_frac is vectorised
  term <- fmdates::year_frac(d1, d2, field(x, "day_basis"))
  # determine compounding frequency for each x value
  compounding <- field(x, "compounding")
  is_cc <- is.infinite(compounding)
  is_simple <- compounding == 0
  is_tbill <- compounding == -1
  is_pc <- !(is_cc | is_simple | is_tbill)
  # determine discount factors
  df <- vector("numeric", length(x))
  value <- field(x, "value")
  df[is_cc] <- exp(-value * term)
  df[is_simple] <- 1 / (1 + value * term)
  df[is_tbill] <- 1 - value * term
  df[is_pc] <- 1 / ((1 + value / compounding) ^
      (compounding * term))
  DiscountFactor(df, d1, d2)
}

#' Inherits from InterestRate
#'
#' Checks whether object inherits from `InterestRate` class
#'
#' @param x an R object
#' @return `TRUE` if `x` inherits from the `InterestRate` class;
#'   otherwise `FALSE`
#' @examples
#' is.InterestRate(InterestRate(0.04, 2, "act/365"))
#' @export

is.InterestRate <- function(x) inherits(x, "InterestRate")

#' Inherits from DiscountFactor
#'
#' Checks whether object inherits from `DiscountFactor` class
#'
#' @param x an R object
#' @return `TRUE` if `x` inherits from the `DiscountFactor` class;
#' otherwise `FALSE`
#' @examples
#' is.DiscountFactor(DiscountFactor(0.97, Sys.Date(), Sys.Date() + 30))
#' @export

is.DiscountFactor <- function(x) inherits(x, "DiscountFactor")

#' Compounding frequencies
#'
#' A non-exported function that checks whether compounding values frequencies
#' are supported.
#'
#' Valid compounding values are:
#' \tabular{ll}{
#'   \bold{Value}  \tab \bold{Frequency}  \cr
#'   -1            \tab Simply, T-bill discounting    \cr
#'   0             \tab Simply                        \cr
#'   1             \tab Annually                      \cr
#'   2             \tab Semi-annually                 \cr
#'   3             \tab Tri-annually                  \cr
#'   4             \tab Quarterly                     \cr
#'   6             \tab Bi-monthly                    \cr
#'   12            \tab Monthly                       \cr
#'   24            \tab Fortnightly                   \cr
#'   52            \tab Weekly                        \cr
#'   365           \tab Daily                         \cr
#'   Inf           \tab Continuously                  \cr
#' }
#'
#' @param compounding a numeric vector representing the compounding frequency
#' @return a flag (\code{TRUE} or \code{FALSE}) if all the supplied compounding
#'   frequencies are supported.
#' @aliases compounding

is_valid_compounding <- function(compounding) {
  COMPOUNDINGS <- c(-1, 0, 1, 2, 3, 4, 6, 12, 24, 52, 365, Inf)
  all(compounding %in% COMPOUNDINGS)
}

assertthat::on_failure(is_valid_compounding) <- function(call, env) {
  paste0(eval(deparse(call$compounding)), " is not a valid compounding frequency.")
}

#' @export
as.double.DiscountFactor <- function(x, ...) field(x, "value")
#' @export
as.double.InterestRate <- function(x, ...) field(x, "value")

#' @export
format.DiscountFactor <- function(x, ...) {
  paste0(field(x, "value"), ", ",
    field(x, "start_date"), "--", field(x, "end_date"))
}

#' @export
obj_print_data.InterestRate <- function(x, ...) {
  cat(paste0(format(x), collapse = "\n"))
}

#' @export
format.InterestRate <- function(x, ...) {
  rp <- format(field(x, "value") * 100, nsmall = 5)
  cmp <- compounding_as_string(field(x, "compounding"))
  db <- field(x, "day_basis")
  toupper(paste0(rp, "%, ", cmp, ", ", db))
}

compounding_as_string <- function (compounding) {
  all_freq <- c(-1, 0, 1, 2, 3, 4, 6, 12, 24, 52, 365, Inf)
  all_string  <- c(
    "SimpleT",
    "Simple",
    "Annual",
    "Semi-annual",
    "Tri-annual",
    "Quarterly",
    "Bi-monthly",
    "Monthly",
    "Fortnightly",
    "Weekly",
    "Daily",
    "Continuous")
  all_string[all_freq %in% compounding]
}
